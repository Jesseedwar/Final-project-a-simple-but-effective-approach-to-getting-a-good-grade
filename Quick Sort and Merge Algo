#include
#include
#include
#include
#include
#include
#include

// Function to generate random ELO data for 3. Scalability Analysis
std::vector generateRandomELOData(size_t size) {
std::vector data(size);
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<> dist(1000, 3000);

for (size_t i = 0; i < size; ++i) {
    data[i] = dist(gen);
}

return data;
}

// Merge Sort implementation
void merge(std::vector& arr, int left, int mid, int right) {
int n1 = mid - left + 1;
int n2 = right - mid;

std::vector<int> L(n1), R(n2);

for (int i = 0; i < n1; i++) L[i] = arr[left + i];
for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i];

int i = 0, j = 0, k = left;
while (i < n1 && j < n2) {
    if (L[i] <= R[j]) {
        arr[k] = L[i];
        i++;
    }
    else {
        arr[k] = R[j];
        j++;
    }
    k++;
}

while (i < n1) {
    arr[k] = L[i];
    i++;
    k++;
}

while (j < n2) {
    arr[k] = R[j];
    j++;
    k++;
}
}

void mergeSort(std::vector& arr, int left, int right) {
if (left < right) {
int mid = left + (right - left) / 2;

    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);

    merge(arr, left, mid, right);
}
}

// Quick Sort implementation
void quickSort(std::vector& arr, int low, int high) {
if (low < high) {
int pivot = arr[high];
int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    int pi = i + 1;

    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
}
}

// This Function is for performing scalability analysis
void scalabilityAnalysis() {
std::vector<size_t> datasetSizes = { 100, 1000, 10000, 100000, 1000000 };
std::cout << "Scalability Analysis:\n";

for (size_t size : datasetSizes) {
    std::cout << "\nDataset size: " << size << "\n";

    // Generates random data
    std::vector<int> data = generateRandomELOData(size);

    // Test For Quick Sort
    std::vector<int> quickData = data;
    auto quickStart = std::chrono::high_resolution_clock::now();
    quickSort(quickData, 0, quickData.size() - 1);
    auto quickEnd = std::chrono::high_resolution_clock::now();
    double quickTime = std::chrono::duration<double>(quickEnd - quickStart).count();
    std::cout << "Quick Sort time: " << quickTime << " seconds.\n";

    // Test For Merge Sort
    std::vector<int> mergeData = data;
    auto mergeStart = std::chrono::high_resolution_clock::now();
    mergeSort(mergeData, 0, mergeData.size() - 1);
    auto mergeEnd = std::chrono::high_resolution_clock::now();
    double mergeTime = std::chrono::duration<double>(mergeEnd - mergeStart).count();
    std::cout << "Merge Sort time: " << mergeTime << " seconds.\n";
}
}

// This Function is used to measure and compare the space complexity
void measureSpaceComplexity() {
std::vector<size_t> datasetSizes = { 100, 1000, 10000, 100000, 1000000 };
std::cout << "Space Complexity Analysis:\n";

for (size_t size : datasetSizes) {
    std::cout << "\nDataset size: " << size << "\n";

    // This Generates random data
    std::vector<int> data = generateRandomELOData(size);

    // This Measure the Quick Sort space usage in the program
    size_t quickSortBaseSize = sizeof(data) + (sizeof(int) * data.size());
    size_t quickSortStackUsage = sizeof(int) * std::ceil(std::log2(data.size()));
    std::cout << "Quick Sort total memory usage: "
        << (quickSortBaseSize + quickSortStackUsage) / 1024.0 << " KB\n";

    // This Measure the Merge Sort space usage in the program
    size_t mergeSortBaseSize = sizeof(data) + (sizeof(int) * data.size());
    size_t mergeSortTemporarySize = sizeof(int) * data.size();
    std::cout << "Merge Sort total memory usage: "
        << (mergeSortBaseSize + mergeSortTemporarySize) / 1024.0 << " KB\n";
}
}

int main() {
try {
std::cout << "Choose sorting method:\n"
<< "1. Quick Sort\n"
<< "2. Merge Sort\n"
<< "3. Scalability Analysis\n"
<< "4. Measure and Compare Space Complexity\n";
int choice;
std::cin >> choice;

    if (choice == 1) {
        std::vector<int> elos = generateRandomELOData(100000);
        auto start = std::chrono::high_resolution_clock::now();
        quickSort(elos, 0, elos.size() - 1);
        auto end = std::chrono::high_resolution_clock::now();
        std::cout << "Quick Sort completed in " << std::chrono::duration<double>(end - start).count() << " seconds.\n";
    }
    else if (choice == 2) {
        std::vector<int> elos = generateRandomELOData(100000);
        auto start = std::chrono::high_resolution_clock::now();
        mergeSort(elos, 0, elos.size() - 1);
        auto end = std::chrono::high_resolution_clock::now();
        std::cout << "Merge Sort completed in " << std::chrono::duration<double>(end - start).count() << " seconds.\n";
    }
    else if (choice == 3) {
        scalabilityAnalysis();
    }
    else if (choice == 4) {
        measureSpaceComplexity();
    }
    else {
        throw std::invalid_argument("Invalid choice!");
    }
}
catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
}
return 0;
